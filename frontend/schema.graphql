type Query {
  userInfo(userId: ID!): User
  nibblesFeatured(user: UserCurrentContextInput): [NibbleAvailable]
  nibblesRecommended(user: UserCurrentContextInput): [NibbleAvailable]
  nibblesWithProperty(
    user: UserCurrentContextInput
    property: NibbleRecommendationReason
  ): [NibbleAvailable]
  closestRestaurants(
    location: LatLon
    paginationInput: PaginationInput
  ): [Restaurant]
  restaurantInformation(restaurantId: ID!): Restaurant
  recentSearch(userId: ID!): [SearchParametersInput]
  search(
    user: UserCurrentContextInput
    searchParameters: SearchParametersInput
  ): SearchResults
}

type Mutation {
  adminCreateRestaurant(
    input: AdminCreateRestaurantInput
  ): AdminCreateRestaurantResponse
  adminCreateNibble(input: AdminNibbleInput): AdminCreateNibbleResponse
  adminDeleteNibble(id: ID!): AdminDeleteNibbleResponse
  adminEditNibble(id: ID!, input: AdminNibbleInput): AdminEditNibbleResponse
  nibbleCancelReservation(
    userId: ID!
    nibbleId: ID!
  ): NibbleCancelReservationResponse
  nibbleCreateReservation(
    userId: ID!
    nibbleId: ID!
  ): NibbleCreateReservationResponse
}

# keep alphabetically sorted below here

type Address {
  id: ID!
  streetAddress: Int!
  dependentLocality: String
  locality: String!
  administrativeArea: String!
  country: String!
  postalCode: String!
  location: LatLon
}

input AdminNibbleInput {
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3Object!
  restaurantId: ID!
  description: String
  price: Price! # price in cents
  availableFrom: ZonedDateTime!
  availableTo: ZonedDateTime!
}

input AdminCreateNibbleResponse {
  id: ID!
}

input AdminCreateRestaurantInput {
  name: String!
  address: Address!
  description: String!
  logoUrl: S3Object!
  heroUrl: S3Object!
  disclaimer: String
}

type AdminCreateRestaurantResponse {
  id: ID!
}

type AdminDeleteNibbleResponse {
  id: ID!
}

type AdminEditNibbleResponse {
  id: ID!
}

type LatLon {
  latitude: Float!
  longitude: Float!
}

"""
Accepts strings in format YYYY-MM-DD HH:MM:SS; does not hold information about
time zone
"""
scalar LocalDateTime

type NibbleAvailable implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  price: Price! # price in cents
  availableFrom: ZonedDateTime!
  availableTo: ZonedDateTime!
}

type NibbleCancelReservationResponse {
  price: Price!
}

interface NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: number!
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
}

type NibbleCreateReservationResponse {
  price: Price!
}

type NibbleHistory implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: number!
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  status: NibbleOrderStatus!
  reservedAt: ZonedDateTime!
  cancelledAt: ZonedDateTime # mandatory if NibbleOrderStatus is CANCELLED*
  cancellationReason: String
}

type NibbleReserved implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: number! # number reserved
  price: Price! # price in cents for entire reservation
  imageUrl: S3Object!
  restaurant: Restaurant!
  reservedAt: ZonedDateTime!
  availableFrom: ZonedDateTime!
  availableTo: ZonedDateTime!
  description: String
}

enum NibbleOrderStatus {
  Reserved
  CancelledByUser
  CancelledByRestaurant
  Completed
}

enum NibbleRecommendationReason {
  Distance
  AvailableNow
}

enum NibbleType {
  Prepared
  Ingredients
  Mystery
}

input PaginationInput {
  offset: Int
  limit: Int
}

"""
Scalar is an integer, representing price in cents
"""
scalar Price

type Restaurant {
  id: ID!
  name: String!
  address: Address!
  description: String!
  logoUrl: S3Object!
  heroUrl: S3Object!
  disclaimer: String
  distance(currentPos: LatLon): Float!
  nibblesAvailable: [NibbleAvailable]!
  active: Boolean!
}

type S3Object {
  bucket: String!
  region: String!
  key: String!
}

input SearchParametersInput {
  text: String!
  maxDistance: Int
  earliestPickup: ZonedDateTime
  latestPickup: ZonedDateTime
  pagination: PaginationInput
}

type SearchRecentQueries {
  recentQueries: [SearchParametersInput]
}

type SearchResults {
  nibbles: [NibbleAvailable]
  restaurants: [Restaurant]
}

"""
The time zone offset in hours from UTC
"""
scalar TimeZone

input UserCurrentContextInput {
  id: ID!
  postalCode: String!
  location: LatLon
}

type User {
  id: ID!
  fullName: String!
  profilePicUrl: S3Object!
  email: String!
  phoneNumber: String
  postalCode: String!
  nibblesReserved: [NibbleReserved]!
  nibblesHistory: [NibbleHistory]!
}

type ZonedDateTime {
  localDateTime: LocalDateTime!
  timeZone: TimeZone!
}
