type Query {
  # gets user ID from identity
  userInfo: User!
  nibblesFeatured(user: UserCurrentContextInput!): [NibbleAvailable]!
  nibbleInfo(nibbleId: ID!): NibbleAvailable!
  nibblesRecommended(user: UserCurrentContextInput!): [NibbleAvailable]!
  nibblesWithProperty(
    user: UserCurrentContextInput!
    property: NibbleRecommendationReason!
  ): [NibbleAvailable]!
  closestRestaurants(
    location: LatLonInput!
    paginationInput: PaginationInput!
  ): [Restaurant]!
  # checks admin id in identity
  restaurantForAdmin: Restaurant!
  restaurantInfo(restaurantId: ID!): Restaurant!
  # gets user ID from identity
  recentSearches: [SearchParameters]
  search(
    user: UserCurrentContextInput!
    searchParameters: SearchParametersInput!
  ): SearchResults!
}

type Mutation {
  adminCreateRestaurant(input: AdminRestaurantInput!): Restaurant!
  adminEditRestaurant(id: ID!, input: AdminRestaurantInput!): Restaurant!
  # restaurants are never deleted, they are only deactivated
  adminDeactivateRestaurant(id: ID!): Restaurant!
  adminCreateNibble(input: AdminNibbleInput!): NibbleAvailable!
  adminEditNibble(id: ID!, input: AdminEditNibbleInput!): NibbleAvailable!
  adminDeleteNibble(id: ID!): AdminDeleteNibbleResponse!
  # used for restaurant to cancel reservation
  adminCancelReservation(
    userId: ID!
    nibbleId: ID!
    reason: String
  ): NibbleCancelReservationResponse!

  # user creates reservation. Nibble reservations are uniquely defined by the
  # user ID and the nibble ID, meaning that a user can only have one
  # reservation per nibble
  nibbleCreateReservation(userId: ID!, nibbleId: ID!, count: Int!): NibbleReserved!
  # user updates reservation
  nibbleEditReservation(userId: ID!, nibbleId: ID!, newCount: Int!): NibbleReserved!
  nibbleCancelReservation(
    userId: ID!
    nibbleId: ID!
    reason: String
  ): NibbleCancelReservationResponse!
  # either restaurant or user can mark reservation as completed
  nibbleCompleteReservation(userId: ID!, nibbleId: ID!): NibbleReserved!
}

# keep alphabetically sorted below here

type Address {
  streetAddress: String!
  dependentLocality: String
  locality: String!
  administrativeArea: String!
  country: String!
  postalCode: String!
  location: LatLon!
}

input AddressInput {
  streetAddress: String!
  dependentLocality: String
  locality: String!
  administrativeArea: String!
  country: String!
  postalCode: String!
  location: LatLonInput! # geolocation should already be done
}

input AdminEditNibbleInput {
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3ObjectInput!
  description: String
  price: Int! # price in cents
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

input AdminNibbleInput {
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3ObjectInput!
  restaurantId: ID!
  description: String
  price: Int! # price in cents
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

input AdminRestaurantInput {
  name: String!
  address: AddressInput!
  market: String!
  description: String!
  logoUrl: S3ObjectInput!
  heroUrl: S3ObjectInput!
  disclaimer: String
  active: Boolean!
}

type AdminDeleteNibbleResponse {
  id: ID!
}

type LatLon {
  latitude: Float!
  longitude: Float!
}

input LatLonInput {
  latitude: Float!
  longitude: Float!
}

type NibbleAvailable {
  id: ID!
  name: String!
  type: NibbleType!
  count: Int! # number available
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  price: Int! # price in cents for one Nibble
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

type NibbleCancelReservationResponse {
  oldPrice: Int!
}

# represents Nibbles that have a reservation, either currently
# or in the past. Nibble reservations are uniquely defined by the user ID
# and the nibble ID, meaning that a user can only have one reservation per
# nibble
type NibbleReserved {
  id: ID!
  name: String!
  type: NibbleType!
  count: Int! # number reserved
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  price: Int! # price in cents for entire reservation
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
  status: NibbleReservationStatus!
  cancelledAt: AWSTimestamp # mandatory if NibbleReservationStatus is CANCELLED*
  cancellationReason: String
  reservedAt: AWSTimestamp!
}

enum NibbleRecommendationReason {
  Distance
  AvailableNow
}

enum NibbleReservationStatus {
  Reserved
  CancelledByUser
  CancelledByRestaurant
  Completed
}

enum NibbleType {
  Prepared
  Ingredients
  Mystery
}

input PaginationInput {
  offset: Int
  limit: Int
}

type Restaurant {
  id: ID!
  name: String!
  market: String!
  address: Address!
  description: String!
  logoUrl: S3Object!
  heroUrl: S3Object!
  disclaimer: String
  distance(currentPos: LatLonInput!): Float!
  nibblesAvailable: [NibbleAvailable]!
  active: Boolean!
}

type S3Object {
  bucket: String!
  region: String!
  key: String!
}

input S3ObjectInput {
  bucket: String!
  region: String!
  key: String!
}

type SearchParameters {
  text: String!
}

input SearchParametersInput {
  text: String!
  maxDistance: Int
  earliestPickup: AWSTimestamp
  latestPickup: AWSTimestamp
  pagination: PaginationInput
}

type SearchRecentQueries {
  recentQueries: [SearchParameters]
}

type SearchResults {
  nibbles: [NibbleAvailable]
  restaurants: [Restaurant]
}

input UserCurrentContextInput {
  id: ID!
  postalCode: String!
  location: LatLonInput
}

type User {
  id: ID!
  fullName: String!
  profilePicUrl: S3Object!
  email: String!
  phoneNumber: String
  postalCode: String
  nibblesReserved: [NibbleReserved]!
  nibblesHistory: [NibbleReserved]!
}

# scalar AWSTimestamp
