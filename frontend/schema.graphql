type Query {
  userInfo(userId: ID!): User!
  nibblesFeatured(user: UserCurrentContextInput!): [NibbleAvailable]!
  nibblesRecommended(user: UserCurrentContextInput!): [NibbleAvailable]!
  nibblesWithProperty(
    user: UserCurrentContextInput!
    property: NibbleRecommendationReason!
  ): [NibbleAvailable]!
  closestRestaurants(
    location: LatLonInput!
    paginationInput: PaginationInput!
  ): [Restaurant]!
  restaurantInfo(restaurantId: ID!): Restaurant!
  recentSearch(userId: ID!): [SearchParameters]
  search(
    user: UserCurrentContextInput!
    searchParameters: SearchParametersInput!
  ): SearchResults!
}

type Mutation {
  adminCreateRestaurant(input: AdminRestaurantInput!): Restaurant!
  adminEditRestaurant(id: ID!, input: AdminRestaurantInput!): Restaurant!
  adminCreateNibble(input: AdminNibbleInput!): NibbleAvailable!
  adminDeleteNibble(id: ID!): AdminDeleteNibbleResponse!
  adminEditNibble(id: ID!, input: AdminEditNibbleInput!): NibbleAvailable!
  nibbleCancelReservation(
    userId: ID!
    nibbleId: ID!
  ): NibbleCancelReservationResponse!
  nibbleCreateReservation(userId: ID!, nibbleId: ID!): NibbleReserved!
}

# keep alphabetically sorted below here

type Address {
  streetAddress: String!
  dependentLocality: String
  locality: String!
  administrativeArea: String!
  country: String!
  postalCode: String!
  location: LatLon!
}

input AddressInput {
  streetAddress: String!
  dependentLocality: String
  locality: String!
  administrativeArea: String!
  country: String!
  postalCode: String!
  location: LatLon! # geolocation should already be done
}

input AdminEditNibbleInput {
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3ObjectInput!
  description: String
  price: Int! # price in cents
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

input AdminNibbleInput {
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3ObjectInput!
  restaurantId: ID!
  description: String
  price: Int! # price in cents
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

input AdminRestaurantInput {
  name: String!
  address: AddressInput!
  location: LatLonInput!
  market: String!
  description: String!
  logoUrl: S3ObjectInput!
  heroUrl: S3ObjectInput!
  disclaimer: String
  active: Boolean!
}

type AdminDeleteNibbleResponse {
  id: ID!
}

type LatLon {
  latitude: Float!
  longitude: Float!
}

input LatLonInput {
  latitude: Float!
  longitude: Float!
}

type NibbleAvailable implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: Int! # number available
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  price: Int! # price in cents
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
}

type NibbleCancelReservationResponse {
  price: Int!
}

interface NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: Int!
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
}

type NibbleCreateReservationResponse {
  price: Int!
}

type NibbleHistory implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: Int!
  imageUrl: S3Object!
  restaurant: Restaurant!
  description: String
  status: NibbleOrderStatus!
  reservedAt: AWSTimestamp!
  cancelledAt: AWSTimestamp # mandatory if NibbleOrderStatus is CANCELLED*
  cancellationReason: String
}

type NibbleReserved implements NibbleCard {
  id: ID!
  name: String!
  type: NibbleType
  count: Int! # number reserved
  price: Int! # price in cents for entire reservation
  imageUrl: S3Object!
  restaurant: Restaurant!
  reservedAt: AWSTimestamp!
  availableFrom: AWSTimestamp!
  availableTo: AWSTimestamp!
  description: String
}

enum NibbleOrderStatus {
  Reserved
  CancelledByUser
  CancelledByRestaurant
  Completed
}

enum NibbleRecommendationReason {
  Distance
  AvailableNow
}

enum NibbleType {
  Prepared
  Ingredients
  Mystery
}

input PaginationInput {
  offset: Int
  limit: Int
}

type Restaurant {
  id: ID!
  name: String!
  market: String!
  address: Address!
  description: String!
  logoUrl: S3Object!
  heroUrl: S3Object!
  disclaimer: String
  distance(currentPos: LatLonInput): Float!
  nibblesAvailable: [NibbleAvailable]!
  active: Boolean!
}

type S3Object {
  bucket: String!
  region: String!
  key: String!
}

input S3ObjectInput {
  bucket: String!
  region: String!
  key: String!
}

type SearchParameters {
  text: String!
}

input SearchParametersInput {
  text: String!
  maxDistance: Int
  earliestPickup: AWSTimestamp
  latestPickup: AWSTimestamp
  pagination: PaginationInput
}

type SearchRecentQueries {
  recentQueries: [SearchParameters]
}

type SearchResults {
  nibbles: [NibbleAvailable]
  restaurants: [Restaurant]
}

input UserCurrentContextInput {
  id: ID!
  postalCode: String!
  location: LatLonInput
}

type User {
  id: ID!
  fullName: String!
  profilePicUrl: S3Object!
  email: String!
  phoneNumber: String
  postalCode: String
  nibblesReserved: [NibbleReserved]!
  nibblesHistory: [NibbleHistory]!
}
